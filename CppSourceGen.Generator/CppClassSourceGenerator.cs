using System.Collections.Immutable;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SourceGeneratorsKit;

namespace CppSourceGen.Generator;

[Generator]
public class CppClassSourceGenerator : IIncrementalGenerator
{
    private void Generate(SourceProductionContext context, ImmutableArray<INamedTypeSymbol?> classSymbols)
    {
	    foreach (INamedTypeSymbol? interfaceSymbol in classSymbols)
	    {
		    if (interfaceSymbol == null)
			    continue;
		    
		    NativeCppClass nativeCppClass = new(context, new RoslynTypeInfo(interfaceSymbol));
		    
		    nativeCppClass.Build(out var marshallableClassesImpl, out var managedToNativeClass);
		    // Build up the source code
		    string source = $@"// <auto-generated/>
#pragma warning disable CS0649

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using CppSourceGen;
using CppSourceGen.Utils;

namespace {interfaceSymbol.ContainingNamespace.ToDisplayString()}
{{
	{string.Join("\n\t", managedToNativeClass.Split('\n'))}
}}

{marshallableClassesImpl}
";

		    // Add the source code to the compilation
		    context.AddSource($"{interfaceSymbol.Name}_Impl.g.cs", source);
	    }
    }

    private static INamedTypeSymbol? Transform(GeneratorSyntaxContext context, CancellationToken token)
    {
	    var symbol = context.SemanticModel.GetDeclaredSymbol(context.Node);
		
	    if (symbol is not INamedTypeSymbol structSymbol)
		    return null;
		
	    if (!symbol.HasAttribute(Marshal.CppClassMarshaller.CPP_INTERFACE_ATTRIBUTE_NAME))
		    return null;

	    return structSymbol;
    }

    private static bool ShouldTransform(SyntaxNode node, CancellationToken token)
    {
	    if (node is not InterfaceDeclarationSyntax)
	    {
		    return false;
	    }
		
	    //TODO: More checks here?
	    return true;
    }
	
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
	    var provider = context.SyntaxProvider
		    .CreateSyntaxProvider(ShouldTransform, Transform)
		    .Collect();
	    
	    context.RegisterSourceOutput(provider, Generate);
    }
}