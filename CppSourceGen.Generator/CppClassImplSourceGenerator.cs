using System.Collections.Immutable;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SourceGeneratorsKit;

namespace CppSourceGen.Generator;

[Generator]
public class CppClassImplSourceGenerator : IIncrementalGenerator
{
    private void Generate(SourceProductionContext context, ImmutableArray<INamedTypeSymbol?> classSymbols)
    {
        foreach (var classSymbol in classSymbols)
        {
            if (classSymbol == null)
                continue;
		    
            NativeCppClassImpl nativeCppClassImpl = new(context, new RoslynTypeInfo(classSymbol));
		    
            nativeCppClassImpl.Build(out var managedToNativeClass);
            // Build up the source code
            string source = $@"// <auto-generated/>
#pragma warning disable CS0649

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using CppSourceGen;
using CppSourceGen.Utils;

namespace {classSymbol.ContainingNamespace.ToDisplayString()}
{{
	{string.Join("\n\t", managedToNativeClass.Split('\n'))}
}}
";

            // Add the source code to the compilation
            context.AddSource($"{classSymbol.Name}_PartialClass.g.cs", source);
        }
    }
    
    private static INamedTypeSymbol? Transform(GeneratorSyntaxContext context, CancellationToken token)
    {
        var symbol = context.SemanticModel.GetDeclaredSymbol(context.Node);
		
        if (symbol is not INamedTypeSymbol structSymbol)
            return null;
		
        if (!symbol.HasAttribute(Marshal.CppClassMarshaller.CPP_INTERFACE_IMPL_ATTRIBUTE_NAME))
            return null;

        return structSymbol;
    }

    private static bool ShouldTransform(SyntaxNode node, CancellationToken token)
    {
        if (node is not ClassDeclarationSyntax)
        {
            return false;
        }
		
        //TODO: More checks here?
        return true;
    }
	
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(ShouldTransform, Transform)
            .Collect();
	    
        context.RegisterSourceOutput(provider, Generate);
    }
}