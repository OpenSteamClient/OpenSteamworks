using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;

[Generator]
public class StructGenerator : IIncrementalGenerator
{
	private class Typedef 
	{
		public string Type { get; }
		public string DefName { get; }
		public List<string> ExtraLines { get; } = new();
		public List<string> XmlDoc { get; } = new();

		public Typedef(string type, string defName) 
		{
			this.Type = type;
			this.DefName = defName;
		}

		public string PrintExtraLines()
		{
			StringBuilder lines = new();
			foreach (var item in ExtraLines)
			{
				lines.AppendLine(item);
			}

			return lines.ToString();
		}

		public string PrintXMLDoc()
		{
			StringBuilder lines = new();
			foreach (var item in XmlDoc)
			{
				lines.AppendLine(item);
			}

			return lines.ToString();
		}
	}

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var definitionFiles = context.AdditionalTextsProvider.Where(file => file.Path.EndsWith(".typedef"));
		var definitionFileContents = definitionFiles.Select((text, cancellationToken) => text.GetText(cancellationToken)!.ToString());
		var provider = definitionFileContents.Collect();

        context.RegisterSourceOutput(provider, (context, definitionFiles) =>
        {
	        StringBuilder debugOutput = new();
	        int numGenerated = 0;
			debugOutput.AppendLine($"// File count: {definitionFiles.Length}");
			for (int i = 0; i < definitionFiles.Length; i++)
			{
				// Alias, typedef
				Dictionary<string, Typedef> typedefs = new();
				string usedNamespace = string.Empty;
				var file = definitionFiles[i];
				var lines = file.Split('\n');
				debugOutput.AppendLine($"// File {i} line count: {lines.Length}");

				IList<string> nestLinesTarget = null;
				int nestingLevel = 0;
				for (int x = 0; x < lines.Length; x++)
				{
					var line = lines[x];
					if (nestingLevel > 0 && line.EndsWith("}"))
					{
						debugOutput.AppendLine($"// Unnest.");
						nestingLevel--;

						if (nestingLevel == 0)
						{
							nestLinesTarget = null;
							continue;
						}
					}

					if (nestingLevel > 0 && line.Contains("{"))
					{
						debugOutput.AppendLine($"// Nest.");
						nestingLevel++;
					}

					if (nestingLevel > 0) {
						nestLinesTarget.Add(line);
						continue;
					}

					if (string.IsNullOrWhiteSpace(line.Trim())) 
					{
						debugOutput.AppendLine($"// Fully white space {line}");
						continue;
					}

					if (line.StartsWith("//")) 
					{
						debugOutput.AppendLine($"// Comment {line}");
						continue;
					}

					if (line.StartsWith("namespace ")) 
					{
						debugOutput.AppendLine($"// Namespace declaration {line}");
						usedNamespace = line;
						continue;
					}

					if (line.StartsWith("typedef ")) 
					{
						debugOutput.AppendLine($"// Typedef {line}");
						var split = line.Split([' ']);

						string type = split[1];
						string alias = split[2].Replace(";", string.Empty);

						type = type.Trim();
						alias = alias.Trim();
						
						var defined = new Typedef(type, alias);
						typedefs[alias] = defined;
						if (!line.EndsWith(";"))
						{
							debugOutput.AppendLine($"// Extra data block starts.");
							nestingLevel++;
							nestLinesTarget = defined.ExtraLines;
						}
						
						continue;
					}

					if (line.StartsWith("xmldoc "))
					{
						debugOutput.AppendLine($"// XMLDoc comment: {line}");
						
						// 'typedef' 'type' '{'
						var split = line.Split([' '], 3);

						string type = split[1];
						type = type.Trim();

						nestingLevel++;
						if (!typedefs.TryGetValue(type, out Typedef def))
						{
							context.ReportDiagnostic(Diagnostic.Create("DSG001", "Syntax", $"Attempted to define xmldoc comment for typedef '{type}' which is not (yet) defined. The xmldoc directive must be preceded by the type definition.", DiagnosticSeverity.Warning, DiagnosticSeverity.Warning, true, 1));
							nestLinesTarget = new List<string>();
							continue;
						}

						nestLinesTarget = def.XmlDoc;
						continue;
					}

					debugOutput.AppendLine($"// Unknown {line}");
				}
				
				var toGenerate = typedefs.Select(kv => kv.Value).ToList();
				Interlocked.Add(ref numGenerated, toGenerate.Count);
				
				foreach (var item in toGenerate)
				{				
					string source = $@"// <auto-generated/>
#nullable enable
#pragma warning disable CS8981

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Numerics;
using System.Diagnostics.CodeAnalysis;

{usedNamespace}

{item.PrintXMLDoc()}
[DebuggerDisplay(""{{m_value}}"")]
public readonly struct {item.DefName} : IComparable, IConvertible, ISpanFormattable, IFormattable, IComparable<{item.DefName}>, IEquatable<{item.DefName}>, IBitwiseOperators<{item.DefName}, {item.DefName}, {item.DefName}>, IComparisonOperators<{item.DefName}, {item.DefName}, bool>, IEqualityOperators<{item.DefName}, {item.DefName}, bool>, ISpanParsable<{item.DefName}>, IParsable<{item.DefName}>, IUtf8SpanFormattable, IUtf8SpanParsable<{item.DefName}> {{
	private readonly {item.Type} m_value;

	private {item.DefName}({item.Type} value) => this.m_value = value;
	public static implicit operator {item.DefName}({item.Type} value) => new(value);
	public static implicit operator {item.Type}({item.DefName} that) => that.m_value;

{item.PrintExtraLines()}

	public readonly int CompareTo(object? obj)
	{{
		if (obj is {item.Type} underlying) {{
			return m_value.CompareTo(underlying);
		}} else if (obj is {item.DefName} t) {{
			return m_value.CompareTo(t.m_value);
		}}

		return 0;
	}}

	public readonly int CompareTo({item.DefName} other) => m_value.CompareTo(other.m_value);
	public readonly bool Equals({item.DefName} other) => m_value.Equals(other.m_value);
	public readonly TypeCode GetTypeCode() => m_value.GetTypeCode();
	public readonly bool ToBoolean(IFormatProvider? provider) => ((IConvertible)m_value).ToBoolean(provider);
	public readonly byte ToByte(IFormatProvider? provider) => ((IConvertible)m_value).ToByte(provider);
	public readonly char ToChar(IFormatProvider? provider) => ((IConvertible)m_value).ToChar(provider);
	public readonly DateTime ToDateTime(IFormatProvider? provider) => ((IConvertible)m_value).ToDateTime(provider);
	public readonly decimal ToDecimal(IFormatProvider? provider) => ((IConvertible)m_value).ToDecimal(provider);
	public readonly double ToDouble(IFormatProvider? provider) => ((IConvertible)m_value).ToDouble(provider);
	public readonly short ToInt16(IFormatProvider? provider) => ((IConvertible)m_value).ToInt16(provider);
	public readonly int ToInt32(IFormatProvider? provider) => ((IConvertible)m_value).ToInt32(provider);
	public readonly long ToInt64(IFormatProvider? provider) => ((IConvertible)m_value).ToInt64(provider);
	public readonly sbyte ToSByte(IFormatProvider? provider) => ((IConvertible)m_value).ToSByte(provider);
	public readonly float ToSingle(IFormatProvider? provider) => ((IConvertible)m_value).ToSingle(provider);
	public readonly string ToString(IFormatProvider? provider) => m_value.ToString(provider);
	public readonly string ToString(string? format, IFormatProvider? formatProvider) => m_value.ToString(format, formatProvider);
	public readonly object ToType(Type conversionType, IFormatProvider? provider) => ((IConvertible)m_value).ToType(conversionType, provider);
	public readonly ushort ToUInt16(IFormatProvider? provider) => ((IConvertible)m_value).ToUInt16(provider);
	public readonly uint ToUInt32(IFormatProvider? provider) => ((IConvertible)m_value).ToUInt32(provider);
	public readonly ulong ToUInt64(IFormatProvider? provider) => ((IConvertible)m_value).ToUInt64(provider);
	public readonly bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider) => m_value.TryFormat(destination, out charsWritten, format, provider);

	public static {item.DefName} Parse(ReadOnlySpan<char> s, IFormatProvider? provider) => {item.Type}.Parse(s, provider);
	public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, [MaybeNullWhen(false)] out {item.DefName} result)
	{{
		bool ret = {item.Type}.TryParse(s, provider, out {item.Type} _result);
		result = new(_result);
		return ret;
	}}

	public static {item.DefName} Parse(string s, IFormatProvider? provider) => {item.Type}.Parse(s, provider);

	public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out {item.DefName} result)
	{{
		bool ret = {item.Type}.TryParse(s, provider, out {item.Type} _result);
		result = new(_result);
		return ret;
	}}

	public bool TryFormat(Span<byte> utf8Destination, out int bytesWritten, ReadOnlySpan<char> format, IFormatProvider? provider) => m_value.TryFormat(utf8Destination, out bytesWritten, format, provider);

	public static {item.DefName} Parse(ReadOnlySpan<byte> utf8Text, IFormatProvider? provider) => {item.Type}.Parse(utf8Text, provider);
	public static bool TryParse(ReadOnlySpan<byte> utf8Text, IFormatProvider? provider, [MaybeNullWhen(false)] out {item.DefName} result)
	{{
		bool ret = {item.Type}.TryParse(utf8Text, provider, out {item.Type} _result);
		result = new(_result);
		return ret;
	}}

	public static {item.DefName} operator ~({item.DefName} value) => ({item.Type})(~value.m_value);
	public static {item.DefName} operator &({item.DefName} left, {item.DefName} right) => ({item.Type})(left.m_value & right.m_value);
	public static {item.DefName} operator |({item.DefName} left, {item.DefName} right) => ({item.Type})(left.m_value | right.m_value);
	public static {item.DefName} operator ^({item.DefName} left, {item.DefName} right) => ({item.Type})(left.m_value ^ right.m_value);

	public static bool operator <({item.DefName} left, {item.DefName} right) => left.m_value < right.m_value;
	public static bool operator >({item.DefName} left, {item.DefName} right) => left.m_value > right.m_value;
	public static bool operator <=({item.DefName} left, {item.DefName} right) => left.m_value <= right.m_value;
	public static bool operator >=({item.DefName} left, {item.DefName} right) => left.m_value >= right.m_value;

	public static bool operator ==({item.DefName} left, {item.DefName} right) => left.m_value == right.m_value;
	public static bool operator !=({item.DefName} left, {item.DefName} right) => left.m_value != right.m_value;

	public override bool Equals(object? obj)
	{{
		if (obj is {item.DefName} t)
		{{
			return this.m_value.Equals(t.m_value);
		}} else if (obj is {item.Type} underlying)
		{{
			return this.m_value.Equals(underlying);
		}}

		return false;
	}}

	public override int GetHashCode() => m_value.GetHashCode();
	public override string ToString() => m_value.ToString();
}}
";

					context.AddSource($"{item.DefName}.g.cs", source);
				}
			}

			context.AddSource("Debug.g.cs", $"// {numGenerated} typedefs total\n{debugOutput}");
		});
	}
}