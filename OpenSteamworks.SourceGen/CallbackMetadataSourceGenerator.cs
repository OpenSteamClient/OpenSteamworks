using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using SourceGeneratorsKit;

[Generator]
public class CallbackMetadataSourceGenerator : ISourceGenerator
{
	public const string ATTRIBUTE_NAME = "OpenSteamworks.Attributes.CallbackAttribute";
	public SyntaxReceiver callbackReceiver = new StructsWithAttributesReceiver(ATTRIBUTE_NAME);
	public const string METADATA_STORE_NAMESPACE = "OpenSteamworks.Callbacks";
	public const string METADATA_STORE_NAME = "CallbackMetadata";


	private StringBuilder generatedToStringMethods = new StringBuilder();
	private StringBuilder generatedIDs = new StringBuilder();
	private StringBuilder generatedIDFromTypeMappings = new StringBuilder();
	private StringBuilder generatedCallbackToStringMappings = new StringBuilder();

	private string GenerateToStringMethod(INamedTypeSymbol structSymbol) {
		StringBuilder builder = new StringBuilder();

		builder.AppendLine($@"
	public static string {structSymbol.Name}_ToString({structSymbol.Name} cb) {{
		StringBuilder builder = new();
		builder.AppendLine(""Begin Callback {structSymbol.Name}"");");
		
		foreach (var item in structSymbol.GetMembers().Where(m => m is IFieldSymbol || m is IPropertySymbol))
		{
			ITypeSymbol type = null;
			if (item is IFieldSymbol fieldSymbol) 
			{
				type = fieldSymbol.Type;
			} else if (item is IPropertySymbol propertySymbol)
			{
				type = propertySymbol.Type;
			}

			if (type is IArrayTypeSymbol) {
				// Handle arrays
				builder.AppendLine($"		builder.AppendLine($\"    {item.Name}: {{EnumerableToString(cb.{item.Name})}}\");");
				continue;
			}

			// Handle everything else
			builder.AppendLine($"		builder.AppendLine($\"    {item.Name}: {{FieldToString(cb.{item.Name})}}\");");
		}

		builder.AppendLine($@"		builder.AppendLine(""End Callback {structSymbol.Name}"");
		return builder.ToString();
	}}");
		return builder.ToString();
	}

	private string ifOrElseIf = "if";
	private string GenerateIDFromTypeMapping(INamedTypeSymbol structSymbol) {
		StringBuilder builder = new StringBuilder();
		builder.AppendLine($"		{ifOrElseIf} (typeof(T) == typeof({structSymbol.Name}))");
		builder.AppendLine($"		{{");
		builder.AppendLine($"			return {structSymbol.Name}_ID;");
		builder.AppendLine($"		}}");
		
		if (ifOrElseIf == "if") {
			ifOrElseIf = "else if";
		}

		return builder.ToString();
	}

	private string GenerateCallbackToStringMapping(INamedTypeSymbol structSymbol)
		=> $"			{structSymbol.Name}_ID => {structSymbol.Name}_ToString(GetStructForCallback<{structSymbol.Name}>(data)),";

	public void Execute(GeneratorExecutionContext context)
    {
        if (!(context.SyntaxContextReceiver is StructsWithAttributesReceiver receiver))
        {
            return;
        }

		// Process every callback struct and generate the sources
        foreach (INamedTypeSymbol structSymbol in receiver.Structs)
        {
			var attr = structSymbol.FindAttribute(ATTRIBUTE_NAME);
			if (attr == null) {
				// Skip this struct if it doesn't have this attribute
				continue;
			}

			int callbackID = (int)attr.ConstructorArguments[0].Value;
			generatedIDs.AppendLine($"	public const int {structSymbol.Name}_ID = {callbackID};");
			generatedToStringMethods.Append(GenerateToStringMethod(structSymbol));
			generatedCallbackToStringMappings.AppendLine(GenerateCallbackToStringMapping(structSymbol));
			generatedIDFromTypeMappings.Append(GenerateIDFromTypeMapping(structSymbol));
        }

		// Concat all this together
		string source = $@"// <auto-generated/>
using System;
using System.Text;
using OpenSteamworks.Callbacks.Structs;

namespace {METADATA_STORE_NAMESPACE};

internal static partial class {METADATA_STORE_NAME} {{
{generatedIDs}

{generatedToStringMethods}

	public static string CallbackToString(int callbackID, byte[] data) {{
		return callbackID switch
		{{
{generatedCallbackToStringMappings}
			_ => string.Empty,
		}};
	}}

	public static int GetIDFromType<T>() where T: struct {{
{generatedIDFromTypeMappings}
		throw new ArgumentException(""Type is not a callback type."", nameof(T));
	}}
}}
";

		// Add the source code to the compilation
		context.AddSource($"CallbackMetadata.g.cs", source);
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => callbackReceiver);
    }
}